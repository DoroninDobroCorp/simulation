Техническое задание на поиск оптимального банкролл-менеджмента

1. Цель проекта

Разработать модульную систему для симуляции и оптимизации ставок, которая:
    •   Генерирует коэффициенты (odds) и ROI с помощью статистических распределений.
    •   Симулирует серию ставок с учётом выигрышей/проигрышей, изменяя банк игрока и отслеживая ключевые показатели (прирост банка, просадки, средний размер ставки).
    •   Реализует несколько стратегий расчёта размера ставки, каждая из которых определяется набором параметров.
    •   Оптимизирует параметры стратегий для различных уровней риска (консервативный, осторожный, сбалансированный, рискованный, экстремальный) через многократные симуляции.
    •   Обеспечивает удобный графический интерфейс (GUI) для ввода параметров, управления симуляцией и визуализации результатов.

2. Функциональные требования

2.1 Генерация распределений
        *      кэф (odd) берется случайным образом от 1,5 до 3,5 однако есть смещение в правую сторону, средний кэф 2.8
    •   Генерация ROI на основе смешанного распределения, комбинирующего три диапазона:
    •   Обычный ROI: диапазон с высокой вероятностью (например, 3–6%).
    •   Средний ROI: диапазон с умеренной вероятностью (например, 6–12%).
    •   Редкий ROI: диапазон с низкой вероятностью (например, 12–20%).
    •   Весовые коэффициенты для каждого диапазона (85% для обычного, 10% для среднего, 5% для редкого).



2.2 Симуляция серии ставок

Система должна:
    •   Для каждой ставки случайным образом генерировать коэффициент и ROI с использованием вышеописанных распределений.
    •   Рассчитывать размер ставки согласно выбранной стратегии.
    •   Обновлять банк игрока: при выигрыше – увеличивать с учётом коэффициента, при проигрыше – уменьшать банк на размер ставки.
    •   Вести историю изменения банка, записывать размеры ставок и отслеживать следующие метрики:
    •   Итоговый банк.
    •   Прирост банка (процентное изменение банка от начального).
    •   Средний размер ставки и процент от начального банка.
    •   Максимальная просадка от максимума и от начального банка.
    •   Обеспечивать возможность досрочного завершения симуляции при достижении критических порогов (банк упал ниже 20% от пика).

2.3 Реализация стратегий расчёта ставки

Система должна реализовывать подбор параметров для всех стратегий из файла bet_strategies.py
   

2.4 Оптимизация и поиск лучших стратегий

Система должна:
    •   Запускать серию симуляций для каждой стратегии с перебором диапазона значений ключевого параметра (например, риск для Келли, базовый процент для линейных стратегий и т.д.).
    •   Собирать метрики по каждой симуляции: итоговый банк, ROI, вероятность банкротства, средний размер ставки, количество просадок (и их пересечения с порогами).
    •   Для каждого уровня риска (консервативный, осторожный, сбалансированный, рискованный, экстремальный) выбирать оптимальные параметры, при которых достигается наилучший баланс между доходностью и уровнем риска.
    •   Формировать итоговый отчёт, включающий сводку по лучшим стратегиям и их параметрам.


2.6 Пользовательский интерфейс
    •   Разработка удобного GUI с использованием PyQt5 для:
    •   Ввода параметров симуляций и оптимизации.
    •   Отображения прогресса симуляций (индикаторы, логирование).
    •   Визуализации результатов (графики истории банка, сравнительные диаграммы, графики размеров ставок).
    •   Вывода итогового отчёта с оптимальными стратегиями и их параметрами.

⸻

3. Технические требования и архитектура
    •   Язык программирования: Python.
    •   Библиотеки:
    •   NumPy, SciPy для статистических вычислений.
    •   Matplotlib для построения графиков.
    •   PyQt5 для создания GUI.
    •   Модульность:
    •   Разделение кода на модули: генерация распределений, симуляция ставок, расчёт стратегий, оптимизация, визуализация.
    •   Многопоточность:
    •   Использование потоков (например, QThread) для выполнения длительных симуляций и обучения нейросети без блокировки интерфейса.
    •   Документирование и тестирование:
    •   Подробное документирование функций и классов.


⸻

4. Критерии приемки
    •   Функциональность:
    •   Корректная генерация распределений коэффициентов и ROI.
    •   Реализация всех заявленных стратегий с возможностью настройки параметров.
    •   Корректная симуляция серии ставок с обновлением банка и вычислением ключевых метрик.
    •   Автоматическая оптимизация параметров с выводом сводного отчёта.
    •   Интерфейс:
    •   Удобный и интуитивно понятный GUI для ввода данных, мониторинга процесса и визуализации результатов.
    •   Надёжность и производительность:
    •   Система способна выполнять большое количество симуляций без зависаний.
    •   Корректная обработка ошибок и предупреждений (например, при делении на ноль или некорректных входных данных).




    Риск-профили

Система должна оценивать стратегии по пяти «границам» риска. Обычно эти границы определяются по количеству симуляций, в которых наблюдаются критические просадки (например, просадка от максимума или от начального банка). Примерные профили могут быть такими:
    1.  Консервативный (Conservative)
— Стратегия, при которой не встречаются симуляции с просадкой более 50% от максимума.
— Оптимальный параметр должен обеспечивать максимально стабильное сохранение капитала, даже если ROI может оказаться ниже.
    2.  Осторожный (Cautious)
— Допускается, что до 3,5% симуляций могут иметь просадку выше 50%.
— Здесь приоритетом является минимизация потерь при умеренном ROI.
    3.  Сбалансированный (Balanced)
— Допускается до 10% симуляций с просадкой свыше 50%.
— При этом стремятся к хорошему соотношению доходности и риска, выбирая параметры, при которых ROI значительный, но риск потерь остаётся на приемлемом уровне.
    4.  Рискованный (Risky)
— Здесь допускается до 5% симуляций с просадкой выше 80%.
— Стратегия может быть агрессивной и давать высокий ROI, но в редких случаях может возникнуть значительная просадка.
    5.  Экстремальный (Extreme)
— Допускается до 50% симуляций с просадкой свыше 80%.
— Это очень агрессивные стратегии, где высокий ROI компенсируется большим риском.



Комментарии к подбору параметров

Итоговая цель: найти оптимальные параметры для каждой границы риска
    1.  Определить для каждой границы риск-профиля целевые значения метрик.
Например, для консервативного профиля — 0% просадок >50%, для осторожного — до 3,5%, для сбалансированного — до 10%, для рискованного — до 5% просадок >80% и для экстремального — до 50%.
    2.  Использовать адаптивный алгоритм подбора параметров для каждой стратегии:
    •   Для каждого риск-профиля перебирать ключевой параметр (или параметры) стратегии.
    •   Для каждого значения параметра проводить серию симуляций и вычислять метрики.
    •   Применять адаптивный алгоритм, чтобы постепенно корректировать значение параметра с учётом динамики метрик.
    •   Фиксировать оптимальное значение параметра, когда достигнуто допустимое отклонение от целевой метрики.
    3.  Сохранять и сравнивать результаты:
    •   Для каждой стратегии и риск-профиля сохранять оптимальные параметры и соответствующие метрики.
    •   Выдавать итоговый отчёт с наилучшими значениями параметров для каждого риск-профиля.


Пример реализации (может содержать ошибки, проверяй)

def adaptive_parameter_tuning(initial_value, lower_bound, upper_bound, 
                              target_metric, tolerance, simulate_func):
    # initial_value - стартовое значение параметра
    # lower_bound, upper_bound - границы параметра
    # target_metric - целевое значение метрики (например, % просадок)
    # tolerance - допустимое отклонение от целевого значения
    # simulate_func - функция, проводящая симуляции для данного параметра и возвращающая метрику

    current_value = initial_value
    step = (upper_bound - lower_bound) / 20  # начальный шаг
    best_value = current_value
    best_metric_diff = abs(simulate_func(current_value) - target_metric)

    while True:
        metric = simulate_func(current_value)
        diff = metric - target_metric

        # Если отклонение меньше допустимого, останавливаем поиск
        if abs(diff) <= tolerance:
            best_value = current_value
            break

        # Если метрика слишком мала, нужно увеличить параметр (если не достигнут верхний предел)
        if diff < 0 and current_value < upper_bound:
            # Увеличиваем шаг, если разница большая
            if abs(diff) > 0.2 * target_metric:
                step *= 1.5
            current_value += step
            current_value = min(current_value, upper_bound)
        # Если метрика превышает целевое значение, уменьшаем параметр
        elif diff > 0 and current_value > lower_bound:
            if abs(diff) > 0.2 * target_metric:
                step *= 1.5
            current_value -= step
            current_value = max(current_value, lower_bound)
        else:
            break

        # Если новый вариант лучше, сохраняем его
        new_diff = abs(simulate_func(current_value) - target_metric)
        if new_diff < best_metric_diff:
            best_value = current_value
            best_metric_diff = new_diff

        # Можно добавить условие остановки, если шаг становится слишком мал или цикл длится слишком долго
        if step < 0.01:
            break

    return best_value



    НАПОСЛЕДОК  - ИЗБЕГАЙ ДОБАВЛЕНИЕ ЛЮБЫХ ФУНКЦИЙ НЕ СОГЛАСОВАВ СО МНОЙ!!!